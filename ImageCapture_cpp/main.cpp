/*
 * TWI_Communication.c
 *
 * Created: 3/13/22 2:34:06 PM
 * Author : Ayaan Ahmed
 */ 



#include <stdint.h>
#include <avr/io.h>
#include <util/twi.h>
#include <util/delay.h>
#include <avr/io.h>
#include "timeout.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "SD_Card/ff.h"
#include "SD_Card/integer.h"
#include <avr/eeprom.h>

#ifndef F_CPU
#define F_CPU 1000000UL //changes from 4000000UL
#endif

FATFS FatFs;	// FatFs work area
FIL *fp;		// fpe object

#define SPI_ACTIVE			0 // SS Pin put Low
#define SPI_INACTIVE		1 // SS Pin put High

/*SPI CLOCK*/
#define SPI_CLOCK_DIV4		0x00
#define SPI_CLOCK_DIV16		0x01
#define SPI_CLOCK_DIV64		0x02
#define SPI_CLOCK_DIV128	0x03
#define SPI_CLOCK_DIV2		0x04
#define SPI_CLOCK_DIV8		0x05
#define SPI_CLOCK_DIV32		0x06

#define CS_SD           1        //SD Card
#define CS_CAM_1        2        //ArduCam 1
#define CS_CAM_2        3        //ArduCam 2
#define SPI_PIN_MOSI	5		//MOSI PIN
#define SPI_PIN_MISO	6		//MISO PIN
#define SPI_PIN_SCK		7		//SCK PIN
#define SPI_DDR			DDRB	//SPI on PORTB
#define SPI_PORT		PORTB	//SPI on PORTB

// Set DQ as AVR MISO
#define DO_INIT()					/* Initialize port MMC DO as input */
#define DO_DQ		PB6 //PB3
#define DO			(PINB &	(1<<DO_DQ))	/* Test for MMC DO ('H':true, 'L':false) */

// Set DQ as AVR MOSI
#define DI_DQ		PB5 //PB2
#define DI_INIT()	DDRB  |= (1<<DI_DQ)	/* Initialize port MMC DI as output */
#define DI_H()		PORTB |= (1<<DI_DQ)	/* Set MMC DI "high" */
#define DI_L()		PORTB &= ~(1<<DI_DQ)	/* Set MMC DI "low" */

// Set DQ as AVR SCK
#define CK_DQ		PB7 //PB1
#define CK_INIT()	DDRB  |= (1<<CK_DQ)	/* Initialize port MMC SCLK as output */
#define CK_H()		PORTB |= (1<<CK_DQ)	/* Set MMC SCLK "high" */
#define	CK_L()		PORTB &= ~(1<<CK_DQ)	/* Set MMC SCLK "low" */

// Use a pin for CS
#define CS_DQ		PB1 //PB0
#define CS_INIT()	DDRB  |= (1<<CS_DQ)	/* Initialize port MMC CS as output */
#define	CS_H()		PORTB |= (1<<CS_DQ)	/* Set MMC CS "high" */
#define CS_L()		PORTB &= ~(1<<CS_DQ)	/* Set MMC CS "low" */

#define PI2C_SDA PA6
#define PI2C_SCL PA7
#define SDA_ON (PORTA |= (1<< PA6))
#define SDA_OFF (PORTA &= ~(1<< PA6))
#define SCL_ON (PORTA |= (1<< PA7))
#define SCL_OFF (PORTA &= ~(1<< PA7))
#define SDA_READ (PINA & (1 << PI2C_SDA))
#define SCL_READ (PINA & (1 << PI2C_SCL))
#define dly() _delay_us(0.1)


void sensor_set(unsigned char reg1, unsigned char reg2, unsigned char data);
void reg_set_jpeg (void);
void reg_set_jpeg_capture (void);
void reg_set_320x240(void);
void reg_set_640x800(void);
void set_bit(uint8_t addr, uint8_t bit, uint8_t SS);

/*---------------------------------------------------------*/
/* User Provided RTC Function called by FatFs module       */
/* Used to provide a Timestamp for SDCard files and folders*/
DWORD get_fattime (void)
{
	// Returns current time packed into a DWORD variable
	return	  ((DWORD)(2013 - 1980) << 25)	// Year 2013
	| ((DWORD)8 << 21)				// Month 7
	| ((DWORD)2 << 16)				// Day 28
	| ((DWORD)20 << 11)				// Hour 0..24
	| ((DWORD)30 << 5)				// Min 0
	| ((DWORD)0 >> 1);				// Sec/2 0
}

/* I2C clock in Hz */
#define SCL_CLOCK  100000L

void spi_master_init(uint8_t mode, uint8_t clock){
	

	//set PB2 to output and set it high
	SPI_DDR |= (1<<CS_CAM_1);
	SPI_PORT|= (1<<CS_CAM_1);
	
	//set PB2 to output and set it high
	SPI_DDR |= (1<<CS_CAM_2);
	SPI_PORT|= (1<<CS_CAM_2);
	
	static volatile uint8_t SPI_CTS	 = SPI_INACTIVE;
	// Set MOSI and SCK output, all others input
	SPI_DDR |= (1<<SPI_PIN_MOSI)|(1<<SPI_PIN_SCK);
	// Enable SPI, Master, set clock rate
	//SPCR = (1<<SPIE)|(1<<SPE)|(1<<MSTR)|(mode<<CPHA)|(clock<<SPR0);
}

static
void xmit_mmc (
const BYTE* buff,	/* Data to be sent */
UINT bc				/* Number of bytes to send */
)
{
	BYTE d;


	do {
		d = *buff++;	/* Get a byte to be sent */
		if (d & 0x80) DI_H(); else DI_L();	/* bit7 */
		CK_H(); CK_L();
		if (d & 0x40) DI_H(); else DI_L();	/* bit6 */
		CK_H(); CK_L();
		if (d & 0x20) DI_H(); else DI_L();	/* bit5 */
		CK_H(); CK_L();
		if (d & 0x10) DI_H(); else DI_L();	/* bit4 */
		CK_H(); CK_L();
		if (d & 0x08) DI_H(); else DI_L();	/* bit3 */
		CK_H(); CK_L();
		if (d & 0x04) DI_H(); else DI_L();	/* bit2 */
		CK_H(); CK_L();
		if (d & 0x02) DI_H(); else DI_L();	/* bit1 */
		CK_H(); CK_L();
		if (d & 0x01) DI_H(); else DI_L();	/* bit0 */
		CK_H(); CK_L();
	} while (--bc);
}

static
void rcvr_mmc (
BYTE *buff,	/* Pointer to read buffer */
UINT bc		/* Number of bytes to receive */
)
{
	BYTE r;


	DI_H();	/* Send 0xFF */

	do {
		r = 0;	 if (DO) r++;	/* bit7 */
		CK_H(); CK_L();
		r <<= 1; if (DO) r++;	/* bit6 */
		CK_H(); CK_L();
		r <<= 1; if (DO) r++;	/* bit5 */
		CK_H(); CK_L();
		r <<= 1; if (DO) r++;	/* bit4 */
		CK_H(); CK_L();
		r <<= 1; if (DO) r++;	/* bit3 */
		CK_H(); CK_L();
		r <<= 1; if (DO) r++;	/* bit2 */
		CK_H(); CK_L();
		r <<= 1; if (DO) r++;	/* bit1 */
		CK_H(); CK_L();
		r <<= 1; if (DO) r++;	/* bit0 */
		CK_H(); CK_L();
		*buff++ = r;			/* Store a received byte */
	} while (--bc);
}

void writeSPI(uint8_t addr, uint8_t data, uint8_t SS) {
	BYTE d[2];
	d[0] = addr;
	d[1] = data;
	
	PORTB&= ~(1<<SS);
	xmit_mmc(d, 2);
	PORTB|= (1<<SS);
	
	/*
	PORTB&= ~(1<<SS);
	SPDR = addr;

	//Wait until transmission complete
	while(!(SPSR & (1<<SPIF) ));

	SPDR = data;

	//Wait until transmission complete
	while(!(SPSR & (1<<SPIF) ));

	PORTB|= (1<<SS);
	*/
}

uint8_t readSPI(uint8_t addr, uint8_t SS) {
	BYTE d[1];
	d[0] = addr;
	
	
	PORTB&= ~(1<<SS);
	xmit_mmc(d, 1);
	rcvr_mmc(d, 1);
	PORTB|= (1<<SS);
	
	//// Send the register address
	//PORTB&= ~(1<<SS);
	//SPDR = addr;
//
	////Wait until transmission complete
	//while(!(SPSR & (1<<SPIF) ));
//
	//// Receive the value from the ArduCAM
	//SPDR = 0x00; //Command
//
	////Wait until transmission complete
	//while(!(SPSR & (1<<SPIF) ));
	//uint8_t data = SPDR;
//
	//PORTB|= (1<<SS);
	
	return d[0];
}

void camInit (uint8_t SS){
	
	if(SS == CS_CAM_1){
		PORTB &= ~(1 << PB4); //low to camera 1, high to camera 2
	}
	
	else if(SS ==  CS_CAM_2){
		PORTB |= (1 << PB4);
	}
	////Reset the CPLD
	writeSPI(0x87, 0x80, SS);
	//_delay_ms(100);
	writeSPI(0x87, 0x00, SS);
	//_delay_ms(100);

	 //Comment it out to see if it is needed
	sensor_set(0x30,0x08, 0x80); //reset
	reg_set_jpeg(); //set all i2c registers
	//_delay_ms(100);
	reg_set_jpeg_capture();
	reg_set_320x240();
	//reg_set_1280x960();
	//reg_set_640x800();
	_delay_ms(100);
	

	sensor_set(0x38,0x18,0xa8);
	sensor_set(0x36,0x21,0x10);
	sensor_set(0x38,0x01,0xb0);
	sensor_set(0x44,0x07, 0x08);
	sensor_set(0x58,0x88,0x00);
	sensor_set(0x50,0x00,0xFF);
	
	
	
	set_bit(0x03,0x02,SS); //vsync bit to 1

	//writeSPI(0x86,0x02); // Power on the sensor
	writeSPI(0x81,0x00,SS); //Set 1 frame to be captured in CCR 0=1
	
	//set_bit(0x03,0x01); //hsync
	//set_bit(0x03,0x10); //FIFO mode on
	//readSPI(0x86);
	//readSPI(0x45);
}

void startCapture(uint8_t SS) {
	writeSPI(0x84,0x01,SS); //flush the fifo
	writeSPI(0x84,0x01,SS); //clear the fifo
	writeSPI(0x84,0x10,SS); //reset fifo write pointer
	writeSPI(0x84,0x20,SS);

	//reg_set();
	// reg_set_320x240();
	//reg_set_1280x960();
	//_delay_ms(1000);
	writeSPI(0x84, 0x02, SS); //start capture

	while (!(readSPI(0x41,SS) & 0x08)); //myCam.get_bit

	//_delay_ms(10);

	// writeSPI(0x84,0x01); //clear fifo flag
}

void i2c_init(void){
	/* initialize TWI clock: 100 kHz clock, TWPS = 0 => prescaler = 1 */
	
	TWSR = 0;                         /* no prescaler */
	TWBR = ((4*F_CPU/SCL_CLOCK)-16)/2;  /* must be > 10 for stable operation */
	DDRA |= (1<<PA6)|(1<<PA7); // Set the bit banging outputs
	SDA_OFF;
	SCL_OFF;
	
}

unsigned char i2c_start(unsigned char address){
	uint8_t   twst;

	// send START condition
	TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);

	// wait until transmission completed
	while(!(TWCR & (1<<TWINT)));

	// check value of TWI Status Register. Mask prescaler bits.
	twst = TW_STATUS & 0xF8;
	if ( (twst != TW_START) && (twst != TW_REP_START)) return 1;

	// send device address
	TWDR = address;
	TWCR = (1<<TWINT) | (1<<TWEN);

	// wail until transmission completed and ACK/NACK has been received
	while(!(TWCR & (1<<TWINT)));

	// check value of TWI Status Register. Mask prescaler bits.
	twst = TW_STATUS & 0xF8;
	if ( (twst != TW_MT_SLA_ACK) && (twst != TW_MR_SLA_ACK) ) return 1;

	return 0;

	}
	/* i2c_start */

void i2c_stop(void){
	/* send stop condition */
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
	
	// wait until stop condition is executed and bus released
	while(TWCR & (1<<TWSTO));

	}
	/* i2c_stop */


unsigned char i2c_write( unsigned char data ){
	uint8_t   twst;
	
	// send data to the previously addressed device
	TWDR = data; //for write only
	TWCR = (1<<TWINT) | (1<<TWEN);

	// wait until transmission completed
	while(!(TWCR & (1<<TWINT)));

	// check value of TWI Status Register. Mask prescaler bits
	twst = TW_STATUS & 0xF8;
	if( twst != TW_MT_DATA_ACK) return 1;
	return 0;

}
/* i2c_write */
	

unsigned char i2c_readNak(void)
{
	TWCR = (1<<TWINT) | (1<<TWEN);
	while(!(TWCR & (1<<TWINT)));
	
	return TWDR;

}
/* i2c_readNak */

	
	/*  i2c start sequence */
	void start(){
		SDA_ON;
		dly();
		SCL_ON;
		dly();
		SDA_OFF;
		dly();
		SCL_OFF;
		dly();
	}
	
	/*  i2c stop sequence */
	void stop(){
		SDA_OFF;
		dly();
		SCL_ON;
		dly();
		SDA_ON;
		dly();
	}
	
	/* Transmit 8 bit data to slave */
	bool Tx(uint8_t dat){

		for(uint8_t i = 8; i; i--){
			(dat & 0x80) ? SDA_ON : SDA_OFF; //Mask for the eight bit
			dat<<=1;  //Move
			dly();
			SCL_ON;
			dly();
			SCL_OFF;
			dly();
		}
		SDA_ON;
		SCL_ON;
		dly();
		bool ack = !SDA_READ;    // Acknowledge bit
		SCL_OFF;
		return ack;
	}
	 
	 
	uint8_t Rx(bool ack){
		uint8_t dat = 0;
		SDA_ON;
		for( uint8_t i =0; i<8; i++){
			dat <<= 1;
			do{
				SCL_ON;
			}while(	(PINA & PA7)== 0);  //clock stretching //if ( PINC & PC1 ) = SDA_READ
			dly();
			if((PINA & PA6)) dat |=1;
			dly();
			SCL_OFF;
		}
		ack ? SDA_OFF : SDA_ON;
		SCL_ON;
		dly();
		SCL_OFF;
		SDA_ON;
		return(dat);
	}
	
	
	
void i2c_bitbang_write(uint8_t reg1, uint8_t reg2, uint8_t data ){
	//DDRB = (1<<DDB1)|(1<<DDB0); // Set the PB0 and PB1 as output
	
		start();
		Tx(0x78);//Transfer the slave address
		Tx(reg1); // register addr part 1
		Tx(reg2); // register addr part 2
		Tx(data); // Data to be written
		stop();
	
	//i2c_start(0x78);
	//
	//i2c_write(reg1);
	//i2c_write(reg2); //write to register 3103
	//
	//i2c_write(data); //write 0x03 to register 3103

}

uint8_t i2c_bitbang_read(uint8_t reg1, uint8_t reg2 ){
	DDRB = (1<<DDB1)|(1<<DDB0); // Set the PB0 and PB1 as output
	
	start();
	Tx(0x78);
	Tx(reg1); // register addr part 1
	Tx(reg2); // register addr part 2
	stop();
	start();
	Tx(0x79);//Transfer the slave address
	uint8_t data = Rx(0);
	stop();
	return data;

}

void sensor_set(unsigned char reg1, unsigned char reg2, unsigned char data)
{
	i2c_start(0x78);
	
	i2c_write(reg1);
	i2c_write(reg2); //write to register 3103
	
	i2c_write(data); //write 0x03 to register 3103
	
	//i2c_bitbang_write(reg1,reg2,data);
}


void set_bit(uint8_t addr, uint8_t bit, uint8_t SS)
{
	uint8_t temp;
	temp = readSPI(addr, SS);
	writeSPI(0x80|addr, temp | bit, SS);
}

void reg_set (void)
{
	
	sensor_set(0x31,0x03, 0x03);
	sensor_set(0x30,0x08, 0x82);
	sensor_set(0x30,0x17,0x7f);
	sensor_set(0x30,0x18,0xfc);
	sensor_set(0x38,0x10,0xc2);
	sensor_set(0x36,0x15,0xf0);
	sensor_set(0x30,0x00,0x00);
	sensor_set(0x30,0x01,0x00);
	sensor_set(0x30, 0x02,0x00);
	sensor_set(0x30, 0x03,0x00);
	sensor_set(0x30, 0x11,0x08);
	sensor_set(0x30, 0x10,0x30);
	sensor_set(0x36, 0x04,0x60);
	sensor_set(0x36, 0x22,0x08);
	sensor_set(0x36, 0x21,0x17);
	sensor_set(0x37, 0x09,0x00);
	sensor_set(0x40, 0x00,0x21);
	sensor_set(0x40, 0x1d,0x02);
	sensor_set(0x36, 0x00,0x54);
	sensor_set(0x36, 0x05,0x04);
	sensor_set(0x36, 0x06,0x3f);
	sensor_set(0x3c, 0x01,0x80);
	sensor_set(0x30, 0x0d,0x21);
	sensor_set(0x36, 0x23,0x22);
	sensor_set(0x50, 0x00,0xcf);
	sensor_set(0x50, 0x20,0x04);
	sensor_set(0x51, 0x81,0x79);
	sensor_set(0x51, 0x82,0x00);
	sensor_set(0x51, 0x85,0x22);
	sensor_set(0x51, 0x97,0x01);
	sensor_set(0x55, 0x00,0x0a);
	sensor_set(0x55, 0x04,0x00);
	sensor_set(0x55, 0x05,0x7f);
	sensor_set(0x50, 0x80,0x08);
	sensor_set(0x30, 0x0e,0x18);
	sensor_set(0x46, 0x10,0x00);
	sensor_set(0x47, 0x1d,0x05);
	sensor_set(0x47, 0x08,0x06);
	sensor_set(0x37, 0x10,0x10);
	sensor_set(0x37, 0x0d,0x06);
	sensor_set(0x36, 0x32,0x41);
	sensor_set(0x37, 0x02,0x40);
	sensor_set(0x36, 0x20,0x37);
	sensor_set(0x36, 0x31,0x01);
	sensor_set(0x37, 0x0c,0xa0);
	sensor_set(0x38, 0x08,0x05);
	sensor_set(0x38, 0x09,0x00);
	sensor_set(0x38, 0x0a,0x03);
	sensor_set(0x38, 0x0b,0xc0);
	sensor_set(0x38, 0x0c,0x0c);
	sensor_set(0x38, 0x0d,0x80);
	sensor_set(0x38, 0x0e,0x07);
	sensor_set(0x38, 0x0f,0xd0);
	sensor_set(0x50, 0x00,0x06);
	sensor_set(0x50, 0x1f,0x03);
	sensor_set(0x35, 0x03,0x07);
	sensor_set(0x35, 0x01,0x73);
	sensor_set(0x35, 0x02,0x80);
	sensor_set(0x35, 0x0b,0x00);
	sensor_set(0x38, 0x18,0xc0);
	sensor_set(0x36, 0x21,0x27);
	sensor_set(0x38, 0x01,0x8a);
	sensor_set(0x3a, 0x00,0x78);
	sensor_set(0x3a, 0x1a,0x04);
	sensor_set(0x3a, 0x13,0x30);
	sensor_set(0x3a, 0x18,0x00);
	sensor_set(0x3a, 0x19,0x7c);
	sensor_set(0x3a, 0x08,0x12);
	sensor_set(0x3a, 0x09,0xc0);
	sensor_set(0x3a, 0x0a,0x0f);
	sensor_set(0x3a, 0x0b,0xa0);
	sensor_set(0x30, 0x04,0xff);
	sensor_set(0x35, 0x0c,0x07);
	sensor_set(0x35, 0x0d,0xd0);
	sensor_set(0x3a, 0x0d,0x08);
	sensor_set(0x3a, 0x0e,0x06);
	sensor_set(0x35, 0x00,0x00);
	sensor_set(0x35, 0x01,0x00);
	sensor_set(0x35, 0x02,0x00);
	sensor_set(0x35, 0x0a,0x00);
	sensor_set(0x35, 0x0b,0x00);
	sensor_set(0x35, 0x03,0x00);
	sensor_set(0x30, 0x30,0x2b);
	sensor_set(0x3a, 0x02,0x00);
	sensor_set(0x3a, 0x03,0x7d);
	sensor_set(0x3a, 0x04,0x00);
	sensor_set(0x3a, 0x14,0x00);
	sensor_set(0x3a, 0x15,0x7d);
	sensor_set(0x3a, 0x16,0x00);
	sensor_set(0x3a, 0x00,0x78);
	sensor_set(0x3a, 0x08,0x09);
	sensor_set(0x3a, 0x09,0x60);
	sensor_set(0x3a, 0x0a,0x07);
	sensor_set(0x3a, 0x0b,0xd0);
	sensor_set(0x3a, 0x0d,0x10);
	sensor_set(0x3a, 0x0e,0x0d);
	sensor_set(0x36, 0x20,0x57);
	sensor_set(0x37, 0x03,0x98);
	sensor_set(0x37, 0x04,0x1c);
	sensor_set(0x58, 0x9b,0x00);
	sensor_set(0x58, 0x9a,0xc0);
	sensor_set(0x36, 0x33,0x07);
	sensor_set(0x37, 0x02,0x10);
	sensor_set(0x37, 0x03,0xb2);
	sensor_set(0x37, 0x04,0x18);
	sensor_set(0x37, 0x0b,0x40);
	sensor_set(0x37, 0x0d,0x02);
	sensor_set(0x36, 0x20,0x52);
	sensor_set(0x50, 0x00,0x06);
	sensor_set(0x50, 0x01,0x01);
	sensor_set(0x50, 0x05,0x00);
	sensor_set(0x38, 0x18,0x80);
	sensor_set(0x36, 0x21,0x17);
	sensor_set(0x38, 0x01,0xb4);
	sensor_set(0xff, 0xff,0xff);
}

void reg_set_jpeg (void){
	sensor_set(0x31, 0x03 ,0x93);
	sensor_set(0x30, 0x08 ,0x82);
	sensor_set(0x30, 0x17 ,0x7f);
	sensor_set(0x30, 0x18 ,0xfc);
	sensor_set(0x38, 0x10 ,0xc2);
	sensor_set(0x36, 0x15 ,0xf0);
	sensor_set(0x30, 0x00 ,0x00);
	sensor_set(0x30, 0x01 ,0x00);
	sensor_set(0x30, 0x02 ,0x5c);
	sensor_set(0x30, 0x03 ,0x00);
	sensor_set(0x30, 0x04 ,0xff);
	sensor_set(0x30, 0x05 ,0xff);
	sensor_set(0x30, 0x06 ,0x43);
	sensor_set(0x30, 0x07 ,0x37);
	sensor_set(0x30, 0x11 ,0x08);
	sensor_set(0x30, 0x10 ,0x10);
	sensor_set(0x46, 0x0c ,0x22);
	sensor_set(0x38, 0x15 ,0x04);
	sensor_set(0x37, 0x0c ,0xa0);
	sensor_set(0x36, 0x02 ,0xfc);
	sensor_set(0x36, 0x12 ,0xff);
	sensor_set(0x36, 0x34 ,0xc0);
	sensor_set(0x36, 0x13 ,0x00);
	sensor_set(0x36, 0x05 ,0x7c);
	sensor_set(0x36, 0x21 ,0x09);
	sensor_set(0x36, 0x22 ,0x60);
	sensor_set(0x36, 0x04 ,0x40);
	sensor_set(0x36, 0x03 ,0xa7);
	sensor_set(0x36, 0x03 ,0x27);
	sensor_set(0x40, 0x00 ,0x21);
	sensor_set(0x40, 0x1d ,0x22);
	sensor_set(0x36, 0x00 ,0x54);
	sensor_set(0x36, 0x05 ,0x04);
	sensor_set(0x36, 0x06 ,0x3f);
	sensor_set(0x3c, 0x01 ,0x80);
	sensor_set(0x50, 0x00 ,0x4f);
	sensor_set(0x50, 0x20 ,0x04);
	sensor_set(0x51, 0x81 ,0x79);
	sensor_set(0x51, 0x82 ,0x00);
	sensor_set(0x51, 0x85 ,0x22);
	sensor_set(0x51, 0x97 ,0x01);
	sensor_set(0x50, 0x01 ,0xff);
	sensor_set(0x55, 0x00 ,0x0a);
	sensor_set(0x55, 0x04 ,0x00);
	sensor_set(0x55, 0x05 ,0x7f);
	sensor_set(0x50, 0x80 ,0x08);
	sensor_set(0x30, 0x0e ,0x18);
	sensor_set(0x46, 0x10 ,0x00);
	sensor_set(0x47, 0x1d ,0x05);
	sensor_set(0x47, 0x08 ,0x06);
	sensor_set(0x38, 0x08 ,0x02);
	sensor_set(0x38, 0x09 ,0x80);
	sensor_set(0x38, 0x0a ,0x01);
	sensor_set(0x38, 0x0b ,0xe0);
	sensor_set(0x38, 0x0e ,0x07);
	sensor_set(0x38, 0x0f ,0xd0);
	sensor_set(0x50, 0x1f ,0x00);
	sensor_set(0x50, 0x00 ,0x4f);
	sensor_set(0x43, 0x00 ,0x30);
	sensor_set(0x35, 0x03 ,0x07);
	sensor_set(0x35, 0x01 ,0x73);
	sensor_set(0x35, 0x02 ,0x80);
	sensor_set(0x35, 0x0b ,0x00);
	sensor_set(0x35, 0x03 ,0x07);
	sensor_set(0x38, 0x24 ,0x11);
	sensor_set(0x35, 0x01 ,0x1e);
	sensor_set(0x35, 0x02 ,0x80);
	sensor_set(0x35, 0x0b ,0x7f);
	sensor_set(0x38, 0x0c ,0x0c);
	sensor_set(0x38, 0x0d ,0x80);
	sensor_set(0x38, 0x0e ,0x03);
	sensor_set(0x38, 0x0f ,0xe8);
	sensor_set(0x3a, 0x0d ,0x04);
	sensor_set(0x3a, 0x0e ,0x03);
	sensor_set(0x38, 0x18 ,0xc1);
	sensor_set(0x37, 0x05 ,0xdb);
	sensor_set(0x37, 0x0a ,0x81);
	sensor_set(0x38, 0x01 ,0x80);
	sensor_set(0x36, 0x21 ,0x87);
	sensor_set(0x38, 0x01 ,0x50);
	sensor_set(0x38, 0x03 ,0x08);
	sensor_set(0x38, 0x27 ,0x08);
	sensor_set(0x38, 0x10 ,0x40);
	sensor_set(0x38, 0x04 ,0x05);
	sensor_set(0x38, 0x05 ,0x00);
	sensor_set(0x56, 0x82 ,0x05);
	sensor_set(0x56, 0x83 ,0x00);
	sensor_set(0x38, 0x06 ,0x03);
	sensor_set(0x38, 0x07 ,0xc0);
	sensor_set(0x56, 0x86 ,0x03);
	sensor_set(0x56, 0x87 ,0xbc);
	sensor_set(0x3a, 0x00 ,0x78);
	sensor_set(0x3a, 0x1a ,0x05);
	sensor_set(0x3a, 0x13 ,0x30);
	sensor_set(0x3a, 0x18 ,0x00);
	sensor_set(0x3a, 0x19 ,0x7c);
	sensor_set(0x3a, 0x08 ,0x12);
	sensor_set(0x3a, 0x09 ,0xc0);
	sensor_set(0x3a, 0x0a ,0x0f);
	sensor_set(0x3a, 0x0b ,0xa0);
	sensor_set(0x35, 0x0c ,0x07);
	sensor_set(0x35, 0x0d ,0xd0);
	sensor_set(0x35, 0x00 ,0x00);
	sensor_set(0x35, 0x01 ,0x00);
	sensor_set(0x35, 0x02 ,0x00);
	sensor_set(0x35, 0x0a ,0x00);
	sensor_set(0x35, 0x0b ,0x00);
	sensor_set(0x35, 0x03 ,0x00);
	sensor_set(0x52, 0x8a ,0x02);
	sensor_set(0x52, 0x8b ,0x04);
	sensor_set(0x52, 0x8c ,0x08);
	sensor_set(0x52, 0x8d ,0x08);
	sensor_set(0x52, 0x8e ,0x08);
	sensor_set(0x52, 0x8f ,0x10);
	sensor_set(0x52, 0x90 ,0x10);
	sensor_set(0x52, 0x92 ,0x00);
	sensor_set(0x52, 0x93 ,0x02);
	sensor_set(0x52, 0x94 ,0x00);
	sensor_set(0x52, 0x95 ,0x02);
	sensor_set(0x52, 0x96 ,0x00);
	sensor_set(0x52, 0x97 ,0x02);
	sensor_set(0x52, 0x98 ,0x00);
	sensor_set(0x52, 0x99 ,0x02);
	sensor_set(0x52, 0x9a ,0x00);
	sensor_set(0x52, 0x9b ,0x02);
	sensor_set(0x52, 0x9c ,0x00);
	sensor_set(0x52, 0x9d ,0x02);
	sensor_set(0x52, 0x9e ,0x00);
	sensor_set(0x52, 0x9f ,0x02);
	sensor_set(0x30, 0x30 ,0x0b);
	sensor_set(0x3a, 0x02 ,0x00);
	sensor_set(0x3a, 0x03 ,0x7d);
	sensor_set(0x3a, 0x04 ,0x00);
	sensor_set(0x3a, 0x14 ,0x00);
	sensor_set(0x3a, 0x15 ,0x7d);
	sensor_set(0x3a, 0x16 ,0x00);
	sensor_set(0x3a, 0x00 ,0x78);
	sensor_set(0x3a, 0x08 ,0x09);
	sensor_set(0x3a, 0x09 ,0x60);
	sensor_set(0x3a, 0x0a ,0x07);
	sensor_set(0x3a, 0x0b ,0xd0);
	sensor_set(0x3a, 0x0d ,0x08);
	sensor_set(0x3a, 0x0e ,0x06);
	sensor_set(0x51, 0x93 ,0x70);
	sensor_set(0x58, 0x9b ,0x04);
	sensor_set(0x58, 0x9a ,0xc5);
	sensor_set(0x40, 0x1e ,0x20);
	sensor_set(0x40, 0x01 ,0x42);
	sensor_set(0x40, 0x1c ,0x04);
	sensor_set(0x52, 0x8a ,0x01);
	sensor_set(0x52, 0x8b ,0x04);
	sensor_set(0x52, 0x8c ,0x08);
	sensor_set(0x52, 0x8d ,0x10);
	sensor_set(0x52, 0x8e ,0x20);
	sensor_set(0x52, 0x8f ,0x28);
	sensor_set(0x52, 0x90 ,0x30);
	sensor_set(0x52, 0x92 ,0x00);
	sensor_set(0x52, 0x93 ,0x01);
	sensor_set(0x52, 0x94 ,0x00);
	sensor_set(0x52, 0x95 ,0x04);
	sensor_set(0x52, 0x96 ,0x00);
	sensor_set(0x52, 0x97 ,0x08);
	sensor_set(0x52, 0x98 ,0x00);
	sensor_set(0x52, 0x99 ,0x10);
	sensor_set(0x52, 0x9a ,0x00);
	sensor_set(0x52, 0x9b ,0x20);
	sensor_set(0x52, 0x9c ,0x00);
	sensor_set(0x52, 0x9d ,0x28);
	sensor_set(0x52, 0x9e ,0x00);
	sensor_set(0x52, 0x9f ,0x30);
	sensor_set(0x52, 0x82 ,0x00);
	sensor_set(0x53, 0x00 ,0x00);
	sensor_set(0x53, 0x01 ,0x20);
	sensor_set(0x53, 0x02 ,0x00);
	sensor_set(0x53, 0x03 ,0x7c);
	sensor_set(0x53, 0x0c ,0x00);
	sensor_set(0x53, 0x0d ,0x0c);
	sensor_set(0x53, 0x0e ,0x20);
	sensor_set(0x53, 0x0f ,0x80);
	sensor_set(0x53, 0x10 ,0x20);
	sensor_set(0x53, 0x11 ,0x80);
	sensor_set(0x53, 0x08 ,0x20);
	sensor_set(0x53, 0x09 ,0x40);
	sensor_set(0x53, 0x04 ,0x00);
	sensor_set(0x53, 0x05 ,0x30);
	sensor_set(0x53, 0x06 ,0x00);
	sensor_set(0x53, 0x07 ,0x80);
	sensor_set(0x53, 0x14 ,0x08);
	sensor_set(0x53, 0x15 ,0x20);
	sensor_set(0x53, 0x19 ,0x30);
	sensor_set(0x53, 0x16 ,0x10);
	sensor_set(0x53, 0x17 ,0x00);
	sensor_set(0x53, 0x18 ,0x02);
	sensor_set(0x54, 0x02 ,0x3f);
	sensor_set(0x54, 0x03 ,0x00);
	sensor_set(0x34, 0x06 ,0x00);
	sensor_set(0x51, 0x80 ,0xff);
	sensor_set(0x51, 0x81 ,0x52);
	sensor_set(0x51, 0x82 ,0x11);
	sensor_set(0x51, 0x83 ,0x14);
	sensor_set(0x51, 0x84 ,0x25);
	sensor_set(0x51, 0x85 ,0x24);
	sensor_set(0x51, 0x86 ,0x06);
	sensor_set(0x51, 0x87 ,0x08);
	sensor_set(0x51, 0x88 ,0x08);
	sensor_set(0x51, 0x89 ,0x7c);
	sensor_set(0x51, 0x8a ,0x60);
	sensor_set(0x51, 0x8b ,0xb2);
	sensor_set(0x51, 0x8c ,0xb2);
	sensor_set(0x51, 0x8d ,0x44);
	sensor_set(0x51, 0x8e ,0x3d);
	sensor_set(0x51, 0x8f ,0x58);
	sensor_set(0x51, 0x90 ,0x46);
	sensor_set(0x51, 0x91 ,0xf8);
	sensor_set(0x51, 0x92 ,0x04);
	sensor_set(0x51, 0x93 ,0x70);
	sensor_set(0x51, 0x94 ,0xf0);
	sensor_set(0x51, 0x95 ,0xf0);
	sensor_set(0x51, 0x96 ,0x03);
	sensor_set(0x51, 0x97 ,0x01);
	sensor_set(0x51, 0x98 ,0x04);
	sensor_set(0x51, 0x99 ,0x12);
	sensor_set(0x51, 0x9a ,0x04);
	sensor_set(0x51, 0x9b ,0x00);
	sensor_set(0x51, 0x9c ,0x06);
	sensor_set(0x51, 0x9d ,0x82);
	sensor_set(0x51, 0x9e ,0x00);
	sensor_set(0x50, 0x25 ,0x80);
	sensor_set(0x55, 0x83 ,0x40);
	sensor_set(0x55, 0x84 ,0x40);
	sensor_set(0x55, 0x80 ,0x02);
	sensor_set(0x50, 0x00 ,0xcf);
	sensor_set(0x37, 0x10 ,0x10);
	sensor_set(0x36, 0x32 ,0x51);
	sensor_set(0x37, 0x02 ,0x10);
	sensor_set(0x37, 0x03 ,0xb2);
	sensor_set(0x37, 0x04 ,0x18);
	sensor_set(0x37, 0x0b ,0x40);
	sensor_set(0x37, 0x0d ,0x03);
	sensor_set(0x36, 0x31 ,0x01);
	sensor_set(0x36, 0x32 ,0x52);
	sensor_set(0x36, 0x06 ,0x24);
	sensor_set(0x36, 0x20 ,0x96);
	sensor_set(0x57, 0x85 ,0x07);
	sensor_set(0x3a, 0x13 ,0x30);
	sensor_set(0x36, 0x00 ,0x52);
	sensor_set(0x36, 0x04 ,0x48);
	sensor_set(0x36, 0x06 ,0x1b);
	sensor_set(0x37, 0x0d ,0x0b);
	sensor_set(0x37, 0x0f ,0xc0);
	sensor_set(0x37, 0x09 ,0x01);
	sensor_set(0x38, 0x23 ,0x00);
	sensor_set(0x50, 0x07 ,0x00);
	sensor_set(0x50, 0x09 ,0x00);
	sensor_set(0x50, 0x11 ,0x00);
	sensor_set(0x50, 0x13 ,0x00);
	sensor_set(0x51, 0x9e ,0x00);
	sensor_set(0x50, 0x86 ,0x00);
	sensor_set(0x50, 0x87 ,0x00);
	sensor_set(0x50, 0x88 ,0x00);
	sensor_set(0x50, 0x89 ,0x00);
	sensor_set(0x30, 0x2b ,0x00);
	sensor_set(0x38, 0x08 ,0x01);
	sensor_set(0x38, 0x09 ,0x40);
	sensor_set(0x38, 0x0a ,0x00);
	sensor_set(0x38, 0x0b ,0xf0);
	sensor_set(0x3a, 0x00 ,0x78);
	sensor_set(0x50, 0x01 ,0xFF);
	sensor_set(0x55, 0x83 ,0x50);
	sensor_set(0x55, 0x84 ,0x50);
	sensor_set(0x55, 0x80 ,0x02);
	sensor_set(0x3c, 0x01 ,0x80);
	sensor_set(0x3c, 0x00 ,0x04);
	sensor_set(0x58, 0x00 ,0x48);
	sensor_set(0x58, 0x01 ,0x31);
	sensor_set(0x58, 0x02 ,0x21);
	sensor_set(0x58, 0x03 ,0x1b);
	sensor_set(0x58, 0x04 ,0x1a);
	sensor_set(0x58, 0x05 ,0x1e);
	sensor_set(0x58, 0x06 ,0x29);
	sensor_set(0x58, 0x07 ,0x38);
	sensor_set(0x58, 0x08 ,0x26);
	sensor_set(0x58, 0x09 ,0x17);
	sensor_set(0x58, 0x0a ,0x11);
	sensor_set(0x58, 0x0b ,0xe );
	sensor_set(0x58, 0x0c ,0xd );
	sensor_set(0x58, 0x0d ,0xe );
	sensor_set(0x58, 0x0e ,0x13);
	sensor_set(0x58, 0x0f ,0x1a);
	sensor_set(0x58, 0x10 ,0x15);
	sensor_set(0x58, 0x11 ,0xd );
	sensor_set(0x58, 0x12 ,0x8 );
	sensor_set(0x58, 0x13 ,0x5 );
	sensor_set(0x58, 0x14 ,0x4 );
	sensor_set(0x58, 0x15 ,0x5 );
	sensor_set(0x58, 0x16 ,0x9 );
	sensor_set(0x58, 0x17 ,0xd );
	sensor_set(0x58, 0x18 ,0x11);
	sensor_set(0x58, 0x19 ,0xa );
	sensor_set(0x58, 0x1a ,0x4 );
	sensor_set(0x58, 0x1b ,0x0 );
	sensor_set(0x58, 0x1c ,0x0 );
	sensor_set(0x58, 0x1d ,0x1 );
	sensor_set(0x58, 0x1e ,0x6 );
	sensor_set(0x58, 0x1f ,0x9 );
	sensor_set(0x58, 0x20 ,0x12);
	sensor_set(0x58, 0x21 ,0xb );
	sensor_set(0x58, 0x22 ,0x4 );
	sensor_set(0x58, 0x23 ,0x0 );
	sensor_set(0x58, 0x24 ,0x0 );
	sensor_set(0x58, 0x25 ,0x1 );
	sensor_set(0x58, 0x26 ,0x6 );
	sensor_set(0x58, 0x27 ,0xa );
	sensor_set(0x58, 0x28 ,0x17);
	sensor_set(0x58, 0x29 ,0xf );
	sensor_set(0x58, 0x2a ,0x9 );
	sensor_set(0x58, 0x2b ,0x6 );
	sensor_set(0x58, 0x2c ,0x5 );
	sensor_set(0x58, 0x2d ,0x6 );
	sensor_set(0x58, 0x2e ,0xa );
	sensor_set(0x58, 0x2f ,0xe );
	sensor_set(0x58, 0x30 ,0x28);
	sensor_set(0x58, 0x31 ,0x1a);
	sensor_set(0x58, 0x32 ,0x11);
	sensor_set(0x58, 0x33 ,0xe );
	sensor_set(0x58, 0x34 ,0xe );
	sensor_set(0x58, 0x35 ,0xf );
	sensor_set(0x58, 0x36 ,0x15);
	sensor_set(0x58, 0x37 ,0x1d);
	sensor_set(0x58, 0x38 ,0x6e);
	sensor_set(0x58, 0x39 ,0x39);
	sensor_set(0x58, 0x3a ,0x27);
	sensor_set(0x58, 0x3b ,0x1f);
	sensor_set(0x58, 0x3c ,0x1e);
	sensor_set(0x58, 0x3d ,0x23);
	sensor_set(0x58, 0x3e ,0x2f);
	sensor_set(0x58, 0x3f ,0x41);
	sensor_set(0x58, 0x40 ,0xe);
	sensor_set(0x58, 0x41 ,0xc);
	sensor_set(0x58, 0x42 ,0xd);
	sensor_set(0x58, 0x43 ,0xc);
	sensor_set(0x58, 0x44 ,0xc);
	sensor_set(0x58, 0x45 ,0xc);
	sensor_set(0x58, 0x46 ,0xc);
	sensor_set(0x58, 0x47 ,0xc);
	sensor_set(0x58, 0x48 ,0xd);
	sensor_set(0x58, 0x49 ,0xe);
	sensor_set(0x58, 0x4a ,0xe);
	sensor_set(0x58, 0x4b ,0xa);
	sensor_set(0x58, 0x4c ,0xe);
	sensor_set(0x58, 0x4d ,0xe);
	sensor_set(0x58, 0x4e ,0x10);
	sensor_set(0x58, 0x4f ,0x10);
	sensor_set(0x58, 0x50 ,0x11);
	sensor_set(0x58, 0x51 ,0xa);
	sensor_set(0x58, 0x52 ,0xf);
	sensor_set(0x58, 0x53 ,0xe);
	sensor_set(0x58, 0x54 ,0x10);
	sensor_set(0x58, 0x55 ,0x10);
	sensor_set(0x58, 0x56 ,0x10);
	sensor_set(0x58, 0x57 ,0xa);
	sensor_set(0x58, 0x58 ,0xe);
	sensor_set(0x58, 0x59 ,0xe);
	sensor_set(0x58, 0x5a ,0xf);
	sensor_set(0x58, 0x5b ,0xf);
	sensor_set(0x58, 0x5c ,0xf);
	sensor_set(0x58, 0x5d ,0xa);
	sensor_set(0x58, 0x5e ,0x9);
	sensor_set(0x58, 0x5f ,0xd);
	sensor_set(0x58, 0x60 ,0xc);
	sensor_set(0x58, 0x61 ,0xb);
	sensor_set(0x58, 0x62 ,0xd);
	sensor_set(0x58, 0x63 ,0x7 );
	sensor_set(0x58, 0x64 ,0x17);
	sensor_set(0x58, 0x65 ,0x14);
	sensor_set(0x58, 0x66 ,0x18);
	sensor_set(0x58, 0x67 ,0x18);
	sensor_set(0x58, 0x68 ,0x16);
	sensor_set(0x58, 0x69 ,0x12);
	sensor_set(0x58, 0x6a ,0x1b);
	sensor_set(0x58, 0x6b ,0x1a);
	sensor_set(0x58, 0x6c ,0x16);
	sensor_set(0x58, 0x6d ,0x16);
	sensor_set(0x58, 0x6e ,0x18);
	sensor_set(0x58, 0x6f ,0x1f);
	sensor_set(0x58, 0x70 ,0x1c);
	sensor_set(0x58, 0x71 ,0x16);
	sensor_set(0x58, 0x72 ,0x10);
	sensor_set(0x58, 0x73 ,0xf );
	sensor_set(0x58, 0x74 ,0x13);
	sensor_set(0x58, 0x75 ,0x1c);
	sensor_set(0x58, 0x76 ,0x1e);
	sensor_set(0x58, 0x77 ,0x17);
	sensor_set(0x58, 0x78 ,0x11);
	sensor_set(0x58, 0x79 ,0x11);
	sensor_set(0x58, 0x7a ,0x14);
	sensor_set(0x58, 0x7b ,0x1e);
	sensor_set(0x58, 0x7c ,0x1c);
	sensor_set(0x58, 0x7d ,0x1c);
	sensor_set(0x58, 0x7e ,0x1a);
	sensor_set(0x58, 0x7f ,0x1a);
	sensor_set(0x58, 0x80 ,0x1b);
	sensor_set(0x58, 0x81 ,0x1f);
	sensor_set(0x58, 0x82 ,0x14);
	sensor_set(0x58, 0x83 ,0x1a);
	sensor_set(0x58, 0x84 ,0x1d);
	sensor_set(0x58, 0x85 ,0x1e);
	sensor_set(0x58, 0x86 ,0x1a);
	sensor_set(0x58, 0x87 ,0x1a);
	sensor_set(0x51, 0x80 ,0xff);
	sensor_set(0x51, 0x81 ,0x52);
	sensor_set(0x51, 0x82 ,0x11);
	sensor_set(0x51, 0x83 ,0x14);
	sensor_set(0x51, 0x84 ,0x25);
	sensor_set(0x51, 0x85 ,0x24);
	sensor_set(0x51, 0x86 ,0x14);
	sensor_set(0x51, 0x87 ,0x14);
	sensor_set(0x51, 0x88 ,0x14);
	sensor_set(0x51, 0x89 ,0x69);
	sensor_set(0x51, 0x8a ,0x60);
	sensor_set(0x51, 0x8b ,0xa2);
	sensor_set(0x51, 0x8c ,0x9c);
	sensor_set(0x51, 0x8d ,0x36);
	sensor_set(0x51, 0x8e ,0x34);
	sensor_set(0x51, 0x8f ,0x54);
	sensor_set(0x51, 0x90 ,0x4c);
	sensor_set(0x51, 0x91 ,0xf8);
	sensor_set(0x51, 0x92 ,0x04);
	sensor_set(0x51, 0x93 ,0x70);
	sensor_set(0x51, 0x94 ,0xf0);
	sensor_set(0x51, 0x95 ,0xf0);
	sensor_set(0x51, 0x96 ,0x03);
	sensor_set(0x51, 0x97 ,0x01);
	sensor_set(0x51, 0x98 ,0x05);
	sensor_set(0x51, 0x99 ,0x2f);
	sensor_set(0x51, 0x9a ,0x04);
	sensor_set(0x51, 0x9b ,0x00);
	sensor_set(0x51, 0x9c ,0x06);
	sensor_set(0x51, 0x9d ,0xa0);
	sensor_set(0x51, 0x9e ,0xa0);
	sensor_set(0x52, 0x8a ,0x00);
	sensor_set(0x52, 0x8b ,0x01);
	sensor_set(0x52, 0x8c ,0x04);
	sensor_set(0x52, 0x8d ,0x08);
	sensor_set(0x52, 0x8e ,0x10);
	sensor_set(0x52, 0x8f ,0x20);
	sensor_set(0x52, 0x90 ,0x30);
	sensor_set(0x52, 0x92 ,0x00);
	sensor_set(0x52, 0x93 ,0x00);
	sensor_set(0x52, 0x94 ,0x00);
	sensor_set(0x52, 0x95 ,0x01);
	sensor_set(0x52, 0x96 ,0x00);
	sensor_set(0x52, 0x97 ,0x04);
	sensor_set(0x52, 0x98 ,0x00);
	sensor_set(0x52, 0x99 ,0x08);
	sensor_set(0x52, 0x9a ,0x00);
	sensor_set(0x52, 0x9b ,0x10);
	sensor_set(0x52, 0x9c ,0x00);
	sensor_set(0x52, 0x9d ,0x20);
	sensor_set(0x52, 0x9e ,0x00);
	sensor_set(0x52, 0x9f ,0x30);
	sensor_set(0x52, 0x82 ,0x00);
	sensor_set(0x53, 0x00 ,0x00);
	sensor_set(0x53, 0x01 ,0x20);
	sensor_set(0x53, 0x02 ,0x00);
	sensor_set(0x53, 0x03 ,0x7c);
	sensor_set(0x53, 0x0c ,0x00);
	sensor_set(0x53, 0x0d ,0x10);
	sensor_set(0x53, 0x0e ,0x20);
	sensor_set(0x53, 0x0f ,0x80);
	sensor_set(0x53, 0x10 ,0x20);
	sensor_set(0x53, 0x11 ,0x80);
	sensor_set(0x53, 0x08 ,0x20);
	sensor_set(0x53, 0x09 ,0x40);
	sensor_set(0x53, 0x04 ,0x00);
	sensor_set(0x53, 0x05 ,0x30);
	sensor_set(0x53, 0x06 ,0x00);
	sensor_set(0x53, 0x07 ,0x80);
	sensor_set(0x53, 0x14 ,0x08);
	sensor_set(0x53, 0x15 ,0x20);
	sensor_set(0x53, 0x19 ,0x30);
	sensor_set(0x53, 0x16 ,0x10);
	sensor_set(0x53, 0x17 ,0x00);
	sensor_set(0x53, 0x18 ,0x02);
	sensor_set(0x53, 0x80 ,0x01);
	sensor_set(0x53, 0x81 ,0x00);
	sensor_set(0x53, 0x82 ,0x00);
	sensor_set(0x53, 0x83 ,0x1f);
	sensor_set(0x53, 0x84 ,0x00);
	sensor_set(0x53, 0x85 ,0x06);
	sensor_set(0x53, 0x86 ,0x00);
	sensor_set(0x53, 0x87 ,0x00);
	sensor_set(0x53, 0x88 ,0x00);
	sensor_set(0x53, 0x89 ,0xE1);
	sensor_set(0x53, 0x8A ,0x00);
	sensor_set(0x53, 0x8B ,0x2B);
	sensor_set(0x53, 0x8C ,0x00);
	sensor_set(0x53, 0x8D ,0x00);
	sensor_set(0x53, 0x8E ,0x00);
	sensor_set(0x53, 0x8F ,0x10);
	sensor_set(0x53, 0x90 ,0x00);
	sensor_set(0x53, 0x91 ,0xB3);
	sensor_set(0x53, 0x92 ,0x00);
	sensor_set(0x53, 0x93 ,0xA6);
	sensor_set(0x53, 0x94 ,0x08);
	sensor_set(0x54, 0x80 ,0x0c);
	sensor_set(0x54, 0x81 ,0x18);
	sensor_set(0x54, 0x82 ,0x2f);
	sensor_set(0x54, 0x83 ,0x55);
	sensor_set(0x54, 0x84 ,0x64);
	sensor_set(0x54, 0x85 ,0x71);
	sensor_set(0x54, 0x86 ,0x7d);
	sensor_set(0x54, 0x87 ,0x87);
	sensor_set(0x54, 0x88 ,0x91);
	sensor_set(0x54, 0x89 ,0x9a);
	sensor_set(0x54, 0x8A ,0xaa);
	sensor_set(0x54, 0x8B ,0xb8);
	sensor_set(0x54, 0x8C ,0xcd);
	sensor_set(0x54, 0x8D ,0xdd);
	sensor_set(0x54, 0x8E ,0xea);
	sensor_set(0x54, 0x8F ,0x1d);
	sensor_set(0x54, 0x90 ,0x05);
	sensor_set(0x54, 0x91 ,0x00);
	sensor_set(0x54, 0x92 ,0x04);
	sensor_set(0x54, 0x93 ,0x20);
	sensor_set(0x54, 0x94 ,0x03);
	sensor_set(0x54, 0x95 ,0x60);
	sensor_set(0x54, 0x96 ,0x02);
	sensor_set(0x54, 0x97 ,0xB8);
	sensor_set(0x54, 0x98 ,0x02);
	sensor_set(0x54, 0x99 ,0x86);
	sensor_set(0x54, 0x9A ,0x02);
	sensor_set(0x54, 0x9B ,0x5B);
	sensor_set(0x54, 0x9C ,0x02);
	sensor_set(0x54, 0x9D ,0x3B);
	sensor_set(0x54, 0x9E ,0x02);
	sensor_set(0x54, 0x9F ,0x1C);
	sensor_set(0x54, 0xA0 ,0x02);
	sensor_set(0x54, 0xA1 ,0x04);
	sensor_set(0x54, 0xA2 ,0x01);
	sensor_set(0x54, 0xA3 ,0xED);
	sensor_set(0x54, 0xA4 ,0x01);
	sensor_set(0x54, 0xA5 ,0xC5);
	sensor_set(0x54, 0xA6 ,0x01);
	sensor_set(0x54, 0xA7 ,0xA5);
	sensor_set(0x54, 0xA8 ,0x01);
	sensor_set(0x54, 0xA9 ,0x6C);
	sensor_set(0x54, 0xAA ,0x01);
	sensor_set(0x54, 0xAB ,0x41);
	sensor_set(0x54, 0xAC ,0x01);
	sensor_set(0x54, 0xAD ,0x20);
	sensor_set(0x54, 0xAE ,0x00);
	sensor_set(0x54, 0xAF ,0x16);
	sensor_set(0x54, 0xB0 ,0x01);
	sensor_set(0x54, 0xB1 ,0x20);
	sensor_set(0x54, 0xB2 ,0x00);
	sensor_set(0x54, 0xB3 ,0x10);
	sensor_set(0x54, 0xB4 ,0x00);
	sensor_set(0x54, 0xB5 ,0xf0);
	sensor_set(0x54, 0xB6 ,0x00);
	sensor_set(0x54, 0xB7 ,0xDF);
	sensor_set(0x54, 0x02 ,0x3f);
	sensor_set(0x54, 0x03 ,0x00);
	sensor_set(0x55, 0x00 ,0x10);
	sensor_set(0x55, 0x02 ,0x00);
	sensor_set(0x55, 0x03 ,0x06);
	sensor_set(0x55, 0x04 ,0x00);
	sensor_set(0x55, 0x05 ,0x7f);
	sensor_set(0x50, 0x25 ,0x80);
	sensor_set(0x3a, 0x0f ,0x30);
	sensor_set(0x3a, 0x10 ,0x28);
	sensor_set(0x3a, 0x1b ,0x30);
	sensor_set(0x3a, 0x1e ,0x28);
	sensor_set(0x3a, 0x11 ,0x61);
	sensor_set(0x3a, 0x1f ,0x10);
	sensor_set(0x56, 0x88 ,0xfd);
	sensor_set(0x56, 0x89 ,0xdf);
	sensor_set(0x56, 0x8a ,0xfe);
	sensor_set(0x56, 0x8b ,0xef);
	sensor_set(0x56, 0x8c ,0xfe);
	sensor_set(0x56, 0x8d ,0xef);
	sensor_set(0x56, 0x8e ,0xaa);
	sensor_set(0x56, 0x8f ,0xaa);
	sensor_set(0xff, 0xff,0xff);
	
}

void reg_set_jpeg_capture (void) {
	// OV5642_ QSXGA _YUV7.5 fps
	// 24 MHz input clock, 24Mhz pclk
	// jpeg mode 7.5fps
	sensor_set(0x35, 0x03 ,0x07);
	sensor_set(0x30, 0x00 ,0x00);
	sensor_set(0x30, 0x01 ,0x00);
	sensor_set(0x30, 0x02 ,0x00);
	sensor_set(0x30, 0x03 ,0x00);
	sensor_set(0x30, 0x05 ,0xff);
	sensor_set(0x30, 0x06 ,0xff);
	sensor_set(0x30, 0x07 ,0x3f);
	sensor_set(0x35, 0x0c ,0x07);
	sensor_set(0x35, 0x0d ,0xd0);
	sensor_set(0x36, 0x02 ,0xe4);
	sensor_set(0x36, 0x12 ,0xac);
	sensor_set(0x36, 0x13 ,0x44);
	sensor_set(0x36, 0x21 ,0x27);
	sensor_set(0x36, 0x22 ,0x08);
	sensor_set(0x36, 0x23 ,0x22);
	sensor_set(0x36, 0x04 ,0x60);
	sensor_set(0x37, 0x05 ,0xda);
	sensor_set(0x37, 0x0a ,0x80);
	sensor_set(0x38, 0x01 ,0x8a);
	sensor_set(0x38, 0x03 ,0x0a);
	sensor_set(0x38, 0x04 ,0x0a);
	sensor_set(0x38, 0x05 ,0x20);
	sensor_set(0x38, 0x06 ,0x07);
	sensor_set(0x38, 0x07 ,0x98);
	sensor_set(0x38, 0x08 ,0x0a);
	sensor_set(0x38, 0x09 ,0x20);
	sensor_set(0x38, 0x0a ,0x07);
	sensor_set(0x38, 0x0b ,0x98);
	sensor_set(0x38, 0x0c ,0x0c);
	sensor_set(0x38, 0x0d ,0x80);
	sensor_set(0x38, 0x0e ,0x07);
	sensor_set(0x38, 0x0f ,0xd0);
	sensor_set(0x38, 0x10 ,0xc2);
	sensor_set(0x38, 0x15 ,0x44);
	sensor_set(0x38, 0x18 ,0xc8);
	sensor_set(0x38, 0x24 ,0x01);
	sensor_set(0x38, 0x27 ,0x0a);
	sensor_set(0x3a, 0x00 ,0x78);
	sensor_set(0x3a, 0x0d ,0x10);
	sensor_set(0x3a, 0x0e ,0x0d);
	sensor_set(0x3a, 0x10 ,0x32);
	sensor_set(0x3a, 0x1b ,0x3c);
	sensor_set(0x3a, 0x1e ,0x32);
	sensor_set(0x3a, 0x11 ,0x80);
	sensor_set(0x3a, 0x1f ,0x20);
	sensor_set(0x3a, 0x00 ,0x78);
	sensor_set(0x46, 0x0b ,0x35);
	sensor_set(0x47, 0x1d ,0x00);
	sensor_set(0x47, 0x13 ,0x03);
	sensor_set(0x47, 0x1c ,0x50);
	sensor_set(0x56, 0x82 ,0x0a);
	sensor_set(0x56, 0x83 ,0x20);
	sensor_set(0x56, 0x86 ,0x07);
	sensor_set(0x56, 0x87 ,0x98);
	sensor_set(0x50, 0x01 ,0x4f);
	sensor_set(0x58, 0x9b ,0x00);
	sensor_set(0x58, 0x9a ,0xc0);
	sensor_set(0x44, 0x07 ,0x04);
	sensor_set(0x58, 0x9b ,0x00);
	sensor_set(0x58, 0x9a ,0xc0);
	sensor_set(0x30, 0x02 ,0x0c);
	sensor_set(0x30, 0x02 ,0x00);
	sensor_set(0x35, 0x03 ,0x00);
	sensor_set(0x30, 0x10, 0x10);
	sensor_set(0x30, 0x11, 0x08);	//0x10
	sensor_set(0x50, 0x00, 0xFF);//enable lens correction
	sensor_set(0xff, 0xff, 0xff);

}

void reg_set_1280x960(void){
	sensor_set(0x38, 0x00 ,0x1 );
	sensor_set(0x38, 0x01 ,0xB0);
	sensor_set(0x38, 0x02 ,0x0 );
	sensor_set(0x38, 0x03 ,0xA );
	sensor_set(0x38, 0x04 ,0xA );
	sensor_set(0x38, 0x05 ,0x20);
	sensor_set(0x38, 0x06 ,0x7 );
	sensor_set(0x38, 0x07 ,0x98);
	sensor_set(0x38, 0x08 ,0x5 );
	sensor_set(0x38, 0x09 ,0x00);
	sensor_set(0x38, 0x0a ,0x3 );
	sensor_set(0x38, 0x0b ,0xC0);
	sensor_set(0x38, 0x0c ,0xc );
	sensor_set(0x38, 0x0d ,0x80);
	sensor_set(0x38, 0x0e ,0x7 );
	sensor_set(0x38, 0x0f ,0xd0);
	sensor_set(0x50, 0x01 ,0x7f);
	sensor_set(0x56, 0x80 ,0x0 );
	sensor_set(0x56, 0x81 ,0x0 );
	sensor_set(0x56, 0x82 ,0xA );
	sensor_set(0x56, 0x83 ,0x20);
	sensor_set(0x56, 0x84 ,0x0 );
	sensor_set(0x56, 0x85 ,0x0 );
	sensor_set(0x56, 0x86 ,0x7 );
	sensor_set(0x56, 0x87 ,0x98);
	sensor_set(0xff, 0xff, 0xff);
}

void reg_set_320x240(void) {
	sensor_set(0x38, 0x00 ,0x1 );
	sensor_set(0x38, 0x01 ,0xa8);
	sensor_set(0x38, 0x02 ,0x0 );
	sensor_set(0x38, 0x03 ,0xA );
	sensor_set(0x38, 0x04 ,0xA );
	sensor_set(0x38, 0x05 ,0x20);
	sensor_set(0x38, 0x06 ,0x7 );
	sensor_set(0x38, 0x07 ,0x98);
	sensor_set(0x38, 0x08 ,0x1 );
	sensor_set(0x38, 0x09 ,0x40);
	sensor_set(0x38, 0x0a ,0x0 );
	sensor_set(0x38, 0x0b ,0xF0);
	sensor_set(0x38, 0x0c ,0xc );
	sensor_set(0x38, 0x0d ,0x80);
	sensor_set(0x38, 0x0e ,0x7 );
	sensor_set(0x38, 0x0f ,0xd0);
	sensor_set(0x50, 0x01 ,0x7f);
	sensor_set(0x56, 0x80 ,0x0 );
	sensor_set(0x56, 0x81 ,0x0 );
	sensor_set(0x56, 0x82 ,0xA );
	sensor_set(0x56, 0x83 ,0x20);
	sensor_set(0x56, 0x84 ,0x0 );
	sensor_set(0x56, 0x85 ,0x0 );
	sensor_set(0x56, 0x86 ,0x7 );
	sensor_set(0x56, 0x87 ,0x98);
	//sensor_set(0x30, 0x11 ,0x0f);  //bit[5:0] div
	sensor_set(0xff, 0xff, 0xff);
}

void reg_set_640x800(void){
	sensor_set(0x38, 0x00 ,0x1 );
	sensor_set(0x38, 0x01 ,0xa8);
	sensor_set(0x38, 0x02 ,0x0 );
	sensor_set(0x38, 0x03 ,0xA );
	sensor_set(0x38, 0x04 ,0xA );
	sensor_set(0x38, 0x05 ,0x20);
	sensor_set(0x38, 0x06 ,0x7 );
	sensor_set(0x38, 0x07 ,0x98);
	sensor_set(0x38, 0x08 ,0x2 );
	sensor_set(0x38, 0x09 ,0x80);
	sensor_set(0x38, 0x0a ,0x1 );
	sensor_set(0x38, 0x0b ,0xe0);
	sensor_set(0x38, 0x0c ,0xc );
	sensor_set(0x38, 0x0d ,0x80);
	sensor_set(0x38, 0x0e ,0x7 );
	sensor_set(0x38, 0x0f ,0xd0);
	sensor_set(0x50, 0x01 ,0x7f);
	sensor_set(0x56, 0x80 ,0x0 );
	sensor_set(0x56, 0x81 ,0x0 );
	sensor_set(0x56, 0x82 ,0xA );
	sensor_set(0x56, 0x83 ,0x20);
	sensor_set(0x56, 0x84 ,0x0 );
	sensor_set(0x56, 0x85 ,0x0 );
	sensor_set(0x56, 0x86 ,0x7 );
	sensor_set(0x56, 0x87 ,0x98);
	sensor_set(0x38, 0x01, 0xb0);
	sensor_set(0xff, 0xff, 0xff);
	
}

void sd_write(uint8_t SS, const char *filename){
	// reboot delay
	_delay_ms(200);
	
	// init sdcard
	UINT bw;
	f_mount(0, &FatFs);		// Give a work area to the FatFs module
	// open file
	fp = (FIL *)malloc(sizeof (FIL));

	uint8_t buf[256];
	int m = 0;
	uint8_t first_frame = 1; 
	
	uint8_t temp=0;
	uint8_t temp_last=0;

	//char *filename = "image420.jpg";	

	while(( temp != 0xD9) | (temp_last !=0xFF)) {
		temp_last =  temp;
		temp = readSPI(0x3D,SS);
		buf[m++] = temp;
		_delay_us(15);
		
		if(m >= 256) {
			PORTD ^= (1 << PD0);
			
			if (first_frame) {
				//PORTD|= (1 << PD1);
				if (f_open(fp, filename, FA_WRITE | FA_CREATE_ALWAYS) == FR_OK) {	// Create a file
					f_write(fp, buf, sizeof(buf), &bw);	// Write data to the file
					f_close(fp); // Close the file
				}
				first_frame = 0;
				
			} else {
				if (f_open(fp, filename, FA_WRITE | FA_OPEN_ALWAYS) == FR_OK) {
					if (f_lseek(fp, f_size(fp)) == FR_OK) {
						f_write(fp, buf, sizeof(buf), &bw);	// Write data to the file
						f_close(fp); // Close the file
					}
				}
			}
			m = 0;
		}
	}
	
	 if(m > 0 ) {
		if (f_open(fp, filename, FA_WRITE | FA_OPEN_ALWAYS) == FR_OK) {
			if (f_lseek(fp, f_size(fp)) == FR_OK) {
				f_write(fp, buf, sizeof(buf), &bw);	// Write data to the file
				f_close(fp); // Close the file
			}
		}
	 }
	 
	 f_close(fp); // Close the file
	 
	 writeSPI(0x84,0x01,SS); //clear fifo flag
}

void imu_write(unsigned char addr, unsigned char data)
{
	i2c_write(0xD0); //b110100 0 0 (write)

	i2c_write(addr);
	i2c_write(data);
	i2c_stop();
	
}

unsigned char imu_read(unsigned char addr) // TODO: Finish
{
	i2c_start(0xD0); //b110100 0 0 (write)
	i2c_write(addr);
	i2c_start(0xD1); //b110100 0 1 (read)
	unsigned char data = i2c_readNak(); //read data ?
	i2c_stop();
	return data;
}

void imu_i2c (void){
	// Initialize:
	// Reset registers (PWR_MGMT_1.DEVICE_RESET)
	imu_write(0x68, 0b10000000);
	// Delay for 1 ms
	_delay_ms(1);
	
	// Test - Read WHO_AM_I = 0xAF
	unsigned char testReg = imu_read(0x75);
	if (testReg == 0xAF){
		PORTD&= ~ (1 << PD0);
	}
}


int main(void) {
	DDRD |= (1 << PD0); DDRD |= (1 << PD1); DDRB |= (1 << PB4);
	DDRB &= ~(1<<PB0);	//set shutter button as input
	
	PORTD &= ~(1 << PD0); //set green led as input
	PORTD &= ~(1 << PD1);//set red led as input
	PORTB &= ~(1 << PB4); //set pb4 as pin for mux (splitting SCL and SDA lines)
	PORTB|= (1<<PB0); // Configure as pull-up (?)
	
	spi_master_init(0,SPI_CLOCK_DIV2);
	i2c_init();
	//imu_i2c();
	
	// Load data into the buffer
	
	//
	//writeSPI(0x80, 0x97, CS_CAM_1);//test
	//
	//
	//uint8_t data = readSPI(0x00, CS_CAM_1);
	//
	//if (data==0x97) {
	//PORTD|= (1 << PD0);
	//}
	//
	//_delay_ms(2000);
	//PORTD &= ~(1 << PD0); //green light
	//
	//
	//writeSPI(0x80, 0x97, CS_CAM_1);//test
	//
	//data = readSPI(0x00, CS_CAM_1);
	//
	//if (data==0x97) {
	//PORTD|= (1 << PD1);
	//}
	//
	//_delay_ms(2000);
	//PORTD &= ~(1 << PD0);
	
	//camInit(CS_CAM_1);
	//camInit(CS_CAM_2);
	
	//PORTD|= (1 << PD0);
	
	//startCapture(CS_CAM_1);
	//startCapture(CS_CAM_2);
	// uint32_t size = readSize();
	
	//char *filename_left = "imageL1.jpg";
	//char *filename_right = "imageR1.jpg";
	//
	char filename_left[30];
	char filename_right[30];
	//
	//sd_write(CS_CAM_1, filename_left);
	//sd_write(CS_CAM_2,filename_right);
	
	//PORTD|= (1 << PD0);
	//PORTD|= (1 << PD1);
	
	
	camInit(CS_CAM_1);
	camInit(CS_CAM_2);
	PORTD |= (1 << PD1);
	
	int fileIndex = 0;
	//fileIndex = eeprom_read_word((uint16_t*)100); // TODO: Doesn't work!!
	while(1) {
		if (!(PINB & (1<<PB0))) { // If button pressed
			PORTD &= ~(1 << PD0);
			PORTD &= ~(1 << PD1);
			 
			startCapture(CS_CAM_1);
			startCapture(CS_CAM_2);
			
			fileIndex++;
			
			snprintf(filename_left, 30, "image%d_L.jpg", fileIndex);
			snprintf(filename_right, 30, "image%d_R.jpg", fileIndex);
			
			//eeprom_update_word((uint16_t*)100, fileIndex);
			
			sd_write(CS_CAM_1, filename_left);
			sd_write(CS_CAM_2, filename_right);
			
			//if(fileIndex == 999){
				//fileIndex = 0;
			//}
			
			PORTD &= ~(1 << PD0);
			PORTD|= (1 << PD1); //GREEN MEANS READY TO BEGIN
		}
	}
	
}